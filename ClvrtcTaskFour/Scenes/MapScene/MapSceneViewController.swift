//
//  MapSceneViewController.swift
//  ClvrtcTaskFour
//
//  Created by Artyom Beldeiko on 21.01.23.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import MapKit

protocol MapSceneDisplayLogic: AnyObject {
    func displayData(ViewModel: MapScene.Data.ViewModel)
}

class MapSceneViewController: UIViewController, MapSceneDisplayLogic {
    
    let locationManager = CLLocationManager()
    let defaultLocation = CLLocation(latitude: 52.425163, longitude: 31.015039)
    
    var interactor: MapSceneBusinessLogic?
    var router: (NSObjectProtocol & MapSceneRoutingLogic & MapSceneDataPassing)?
    var currentLocation: CLLocation?
    
    let mapView: MKMapView = {
        let view = MKMapView()
        view.mapType = .standard
        view.isZoomEnabled = true
        view.isScrollEnabled = true
        view.isPitchEnabled = true
        view.showsUserLocation = true
        return view
    }()
    
    let activityIndicatorContainer: UIView = {
        let view = UIView()
        view.backgroundColor = UIColor(named: "background")
        return view
    }()
    
    let activityIndicator: UIActivityIndicatorView = {
        let activityIndicator = UIActivityIndicatorView(style: .large)
        activityIndicator.color = UIColor(named: "titleColor")
        return activityIndicator
    }()
        
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setup()
        configureMapView()
        presentActivityIndicator()
        makeUIInactive()
        
        fetchData()
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        activityIndicator.center = view.center
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestWhenInUseAuthorization()
    }
    
    func fetchData() {
        let request = MapScene.Data.Request()
        interactor?.fetchData(request: request)
    }
        
    func displayData(ViewModel: MapScene.Data.ViewModel) {
        
        DispatchQueue.main.async {
            self.mapView.addAnnotations(ViewModel.MKAnnotatedBranchBank ?? [])
            self.mapView.addAnnotations(ViewModel.MKAnnotatedATM ?? [])
            self.mapView.addAnnotations(ViewModel.MKAnnotatedServiceTerminal ?? [])
            self.activityIndicatorContainer.isHidden = true
            self.makeUIActive()
        }
        
        if ViewModel.MKAnnotatedServiceTerminal?.count == 0 {
            showServiceTerminalFetchFailureAlert()
        } else if ViewModel.MKAnnotatedATM?.count == 0 {
            showAtmFetchFailureAlert()
        } else if ViewModel.MKAnnotatedBranchBank?.count == 0 {
            showBranchBankFetchFailureAlert()
        }
    }
        
    func showAtmFetchFailureAlert() {
        let networkFetchFailureAlert = UIAlertController(title: "Ошибка", message: "Не удалось загрузить данные о банкоматах", preferredStyle: .alert)
        
        let retryAction = UIAlertAction(title: "Повторить еще раз", style: .default) { _ in
            self.fetchData()
        }
        
        let cancelAction = UIAlertAction(title: "Закрыть", style: .cancel) { _ in
            networkFetchFailureAlert.dismiss(animated: true)
        }
        
        networkFetchFailureAlert.addAction(retryAction)
        networkFetchFailureAlert.addAction(cancelAction)
        
        DispatchQueue.main.async {
            self.present(networkFetchFailureAlert, animated: true)
        }
    }
    
    func showBranchBankFetchFailureAlert() {
        let networkFetchFailureAlert = UIAlertController(title: "Ошибка", message: "Не удалось загрузить данные о подразделениях банка", preferredStyle: .alert)
        
        let retryAction = UIAlertAction(title: "Повторить еще раз", style: .default) { _ in
            self.fetchData()
        }
        
        let cancelAction = UIAlertAction(title: "Закрыть", style: .cancel) { _ in
            networkFetchFailureAlert.dismiss(animated: true)
        }
        
        networkFetchFailureAlert.addAction(retryAction)
        networkFetchFailureAlert.addAction(cancelAction)
        
        DispatchQueue.main.async {
            self.present(networkFetchFailureAlert, animated: true)
        }
    }
    
    func showServiceTerminalFetchFailureAlert() {
        let networkFetchFailureAlert = UIAlertController(title: "Ошибка", message: "Не удалось загрузить данные об инфокиосках", preferredStyle: .alert)
        
        let retryAction = UIAlertAction(title: "Повторить еще раз", style: .default) { _ in
            self.fetchData()
        }
        
        let cancelAction = UIAlertAction(title: "Закрыть", style: .cancel) { _ in
            networkFetchFailureAlert.dismiss(animated: true)
        }
        
        networkFetchFailureAlert.addAction(retryAction)
        networkFetchFailureAlert.addAction(cancelAction)
        
        DispatchQueue.main.async {
            self.present(networkFetchFailureAlert, animated: true)
        }
    }
    
    func showNoInternerConnectionAlert() {
        let noInternerConnectionAlert = UIAlertController(title: nil, message: "Приложение работает без доступа к интернету", preferredStyle: .alert)
        
        let okAction = UIAlertAction(title: "Хорошо", style: .default) { _ in
            noInternerConnectionAlert.dismiss(animated: true)
        }
        
        noInternerConnectionAlert.addAction(okAction)
        
        DispatchQueue.main.async {
            self.present(noInternerConnectionAlert, animated: true)
        }
    }
}

// MARK: - MapSceneViewController private funcs

extension MapSceneViewController {
    
    private func setup() {
        let viewController = self
        let interactor = MapSceneInteractor()
        let presenter = MapScenePresenter()
        let router = MapSceneRouter()
        let dbWorker = MapSceneDBWorker()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        interactor.dbWorker = dbWorker
        presenter.viewController = viewController
        presenter.dbWorker = dbWorker
        router.viewController = viewController
        router.dataStore = interactor
        dbWorker.interactor = interactor
        dbWorker.presenter = presenter
    }
    
    private func configureMapView() {
        mapView.delegate = self
        view.addSubview(mapView)
        mapView.frame = view.bounds
    }
    
    private func presentActivityIndicator() {
        view.addSubview(activityIndicatorContainer)
        activityIndicatorContainer.frame = view.bounds
        activityIndicatorContainer.addSubview(activityIndicator)
        activityIndicator.startAnimating()
    }
    
    private func renderLocation(_ location: CLLocation) {
        let coordinate = CLLocationCoordinate2D(latitude: location.coordinate.latitude,
                                                longitude: location.coordinate.longitude)
        let span = MKCoordinateSpan(latitudeDelta: 0.02, longitudeDelta: 0.02)
        let region = MKCoordinateRegion(center: coordinate, span: span)
        
        mapView.setRegion(region, animated: true)
    }
    
    func makeUIInactive() {
        if let parentVC = self.parent as? MainSceneViewController {
            parentVC.viewContainerSegmentedControl.isUserInteractionEnabled = false
            parentVC.navigationItem.rightBarButtonItem?.isEnabled = false
        }
    }
    
    func makeUIActive() {
        if let parentVC = self.parent as? MainSceneViewController {
            parentVC.viewContainerSegmentedControl.isUserInteractionEnabled = true
            parentVC.navigationItem.rightBarButtonItem?.isEnabled = true
        }
    }
}

// MARK: - MKMapViewDelegate

extension MapSceneViewController: MKMapViewDelegate {
    
    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
        if (annotation.isKind(of: MKUserLocation.self)) {
            return nil
        }
        
        let atmAnnotationIdentifier = "atmAnnotation"
        let branchBankIdentifier = "branchBankAnnotation"
        let serviceTerminalIdentifier = "serviceTerminalAnnotation"
        
        var view: MKAnnotationView!
        
        if let dequedView = mapView.dequeueReusableAnnotationView(withIdentifier: atmAnnotationIdentifier) {
            view = dequedView
            view.annotation = annotation as? MKAnnotatedATM
        } else {
            if let annotatedATM = annotation as? MKAnnotatedATM {
                view = MKAnnotationView(annotation: annotatedATM, reuseIdentifier: atmAnnotationIdentifier)
                view.canShowCallout = true
                view.detailCalloutAccessoryView = ATMCalloutView(mkAnnotatedATM: annotatedATM)
                view.image = UIImage(named: "atm")
                view.frame.size = CGSize(width: 50, height: 50)
            }
        }
        
        if let dequedView = mapView.dequeueReusableAnnotationView(withIdentifier: branchBankIdentifier) {
            view = dequedView
            view.annotation = annotation as? MKAnnotatedBranchBank
        } else {
            if let annotatedBranchBank = annotation as? MKAnnotatedBranchBank {
                view = MKAnnotationView(annotation: annotatedBranchBank, reuseIdentifier: branchBankIdentifier)
                view.canShowCallout = true
                view.detailCalloutAccessoryView = BranchBankCalloutView(mkAnnotatedBranchBank: annotatedBranchBank)
                view.image = UIImage(named: "bank")
                view.frame.size = CGSize(width: 50, height: 50)
            }
        }
        
        if let dequedView = mapView.dequeueReusableAnnotationView(withIdentifier: serviceTerminalIdentifier) {
            view = dequedView
            view.annotation = annotation as? MKAnnotatedServiceTerminal
        } else {
            if let annotatedServiceTerminal = annotation as? MKAnnotatedServiceTerminal {
                view = MKAnnotationView(annotation: annotatedServiceTerminal, reuseIdentifier: serviceTerminalIdentifier)
                view.canShowCallout = true
                view.detailCalloutAccessoryView = ServiceTerminalCalloutView(mkAnnotatedServiceTerminal: annotatedServiceTerminal)
                view.image = UIImage(named: "terminal")
                view.frame.size = CGSize(width: 50, height: 50)
            }
        }
        return view
    }
}

// MARK: - CLLocationManagerDelegate

extension MapSceneViewController: CLLocationManagerDelegate {
    
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        if CLLocationManager.locationServicesEnabled() {
            switch locationManager.authorizationStatus {
            case .notDetermined:
                locationManager.requestWhenInUseAuthorization()
                
            case .authorizedAlways, .authorizedWhenInUse:
                
                if Reachability.isConnectedToNetwork() {
                    locationManager.requestWhenInUseAuthorization()
                    locationManager.startUpdatingLocation()
                } else {
                    renderLocation(defaultLocation)
                    currentLocation = defaultLocation
                }
                
            case .denied, .restricted:
                showGeoDataRequestAlert()
                
            @unknown default:
                break
            }
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let location = locations.first {
            locationManager.stopUpdatingLocation()
            
            if Reachability.isConnectedToNetwork() {
                renderLocation(location)
                currentLocation = location
            } else {
                renderLocation(defaultLocation)
                currentLocation = defaultLocation
            }
        }
    }
    
    private func showGeoDataRequestAlert() {
        let geoDataRequestAlert = UIAlertController(title: "Доступ к геолокации", message: "Разрешите доступ для определения Вашего местоположения", preferredStyle: .alert)
        
        let goToSettingAction = UIAlertAction(title: "Перейти в настройки", style: .default) { _ in
            if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                UIApplication.shared.open(settingsUrl)
            }
            geoDataRequestAlert.dismiss(animated: true)
        }
        
        let cancelAction = UIAlertAction(title: "Закрыть", style: .cancel) { _ in
            geoDataRequestAlert.dismiss(animated: true)
        }
        
        geoDataRequestAlert.addAction(goToSettingAction)
        geoDataRequestAlert.addAction(cancelAction)
        
        self.present(geoDataRequestAlert, animated: true)
    }
}

// MARK: - ATMCalloutViewDelegate, BranchBankCalloutViewDelegate, ServiceTerminalCalloutViewDelegate

extension MapSceneViewController: ATMCalloutViewDelegate, BranchBankCalloutViewDelegate, ServiceTerminalCalloutViewDelegate {
    func mapView(_ mapView: MKMapView, didTapCloseButton button: UIButton, for annotation: MKAnnotation) {
        mapView.deselectAnnotation(annotation, animated: true)
    }
    
    func mapView(_ mapView: MKMapView, didTapDetailButton button: UIButton, for annotation: MKAnnotation) {
        guard let annotatedATMData = annotation as? MKAnnotatedATM else { return }
        
        let atmDetailedVC = ATMDetailedInfoViewController()
        
        atmDetailedVC.idLabel.text = "Идентификатор банкомата: \(annotatedATMData.atmID)"
        
        if annotatedATMData.type == "ATM" {
            atmDetailedVC.typeLabel.text = "Тип: банкомат"
        } else {
            atmDetailedVC.typeLabel.text = "Тип: не установлено"
        }
        
        atmDetailedVC.baseCurrencyLabel.text = "Cтандартная валюта: \(annotatedATMData.baseCurrency)"
        atmDetailedVC.currencyLabel.text = "Выдаваемая валюта: \(annotatedATMData.currency)"
        atmDetailedVC.cardsLabel.text = "Платежные системы: \(annotatedATMData.cards)"
        
        if annotatedATMData.currentStatus == "On" {
            atmDetailedVC.currentStatusLabel.text = "Текущее состояние: работает"
        } else {
            atmDetailedVC.currentStatusLabel.text = "Текущее состояние: не работает"
        }
        
        atmDetailedVC.addressLabel.text = "Адрес: \(annotatedATMData.townName), \(annotatedATMData.streetName) \(annotatedATMData.buildingNumber) (\(annotatedATMData.addressLine))"
        atmDetailedVC.geolocationLabel.text = "Географические координаты: долгота - \(annotatedATMData.longitude), широта - \(annotatedATMData.latitude)"
        atmDetailedVC.servicesLabel.text = "Услуги: \(annotatedATMData.serviceType)"
        
        if annotatedATMData.access24Hours == true {
            atmDetailedVC.access24hoursLabel.text = "Работает круглосуточно: да"
        } else {
            atmDetailedVC.access24hoursLabel.text = "Работает круглосуточно: нет"
        }
        
        if annotatedATMData.isRescticted == true {
            atmDetailedVC.restrictedAccessLabel.text = "Доступ ограничен: да"
        } else {
            atmDetailedVC.restrictedAccessLabel.text = "Доступ ограничен: нет"
        }
        
        if annotatedATMData.sameAsOrganization == true {
            atmDetailedVC.organizationOperatingHoursLabel.text = "Работа по графику организации-местонахождения банкомата: да"
        } else {
            atmDetailedVC.organizationOperatingHoursLabel.text = "Работа по графику организации-местонахождения банкомата: да"
        }
        
        atmDetailedVC.standardAvailabilityLabel.text = "Режим работы: \(annotatedATMData.standardAvailability)"
        atmDetailedVC.contactDetailsLabel.text = "Контактный номер телефона: \(annotatedATMData.contactDetails)"
        atmDetailedVC.atmItemLatitude = annotatedATMData.coordinate.latitude
        atmDetailedVC.atmItemLongitude = annotatedATMData.coordinate.longitude
        atmDetailedVC.atmItemTitle = "Belarusbank ATM \(annotatedATMData.streetName),  \(annotatedATMData.buildingNumber)"
        
        self.present(atmDetailedVC, animated: true)
    }
}



